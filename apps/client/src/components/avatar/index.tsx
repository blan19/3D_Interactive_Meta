/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/city city.glb -o src/components/city/index.jsx -r public
*/

import {
  Html,
  PerspectiveCamera,
  useAnimations,
  useGLTF,
} from '@react-three/drei';
import { memo, useEffect, useMemo, useRef, useState } from 'react';
import { SkeletonUtils } from 'three-stdlib';
import { RapierRigidBody, RigidBody, vec3, quat } from '@react-three/rapier';
import { useFrame } from '@react-three/fiber';
import { Vector3, Group } from '../../lib/three';
import { socket } from '../../lib/socket';
import { useUserStore } from '../../store';

interface AvatarProps {
  url: string;
  id: string;
  nickname: string;
  speed?: number;
  direction?: InstanceType<typeof Vector3>;
  frontVector?: InstanceType<typeof Vector3>;
  sideVector?: InstanceType<typeof Vector3>;
  position?: InstanceType<typeof Vector3>;
}

interface PressedType {
  back: boolean;
  forward: boolean;
  left: boolean;
  right: boolean;
  jump: boolean;
}

const PRESSED_INITIAL_STATE = {
  back: false,
  forward: false,
  left: false,
  right: false,
  jump: false,
};

type ANIMATIONS_STATE = 'M_Standing_Idle_001' | 'M_Walk_001';

const Chat = ({ id }: { id: string }) => {
  // chat
  const [chat, setChat] = useState('');
  const [showChatBubble, setShowChatBubble] = useState(false);

  let chatMessageBubbleTimeout: number | undefined;
  const onChatMessage = (value: { id: string; chat: string }) => {
    const { id: socketId, chat: newChat } = value;
    if (socketId === id) {
      setChat(newChat);
      clearTimeout(chatMessageBubbleTimeout);
      setShowChatBubble(true);
      chatMessageBubbleTimeout = setTimeout(() => {
        setShowChatBubble(false);
      }, 3500);
    }
  };

  useEffect(() => {
    socket.on('playerChat', onChatMessage);

    return () => {
      socket.off('playerChat', onChatMessage);
    };
  }, [id]);

  return (
    <Html position-y={2.5}>
      <div className="w-60 max-w-full">
        <p
          className={`absolute max-w-full -translate-x-1/2 -translate-y-full break-words rounded-lg bg-white bg-opacity-40 p-2 px-4 text-center text-black backdrop-blur-sm transition-opacity duration-500 ${
            showChatBubble ? '' : 'opacity-0'
          }`}
        >
          {chat}
        </p>
      </div>
    </Html>
  );
};

const Avatar = memo(function AvatarImpl({
  url,
  id,
  nickname,
  speed = 3,
  direction = new Vector3(),
  frontVector = new Vector3(),
  sideVector = new Vector3(),
  ...props
}: AvatarProps) {
  const rb = useRef<InstanceType<typeof RapierRigidBody>>(null);
  const avatar = useRef<InstanceType<typeof Group>>(null);
  const lookAt = useRef<ReturnType<typeof vec3>>(vec3({ x: 0, y: 0, z: 0 }));
  const pressed = useRef<PressedType>(PRESSED_INITIAL_STATE);
  const { id: userId } = useUserStore();
  const { scene } = useGLTF(url);

  // animation
  const { animations: walkAnimation } = useGLTF('/animations/M_Walk_001.glb');
  const { animations: idleAnimation } = useGLTF(
    '/animations/M_Standing_Idle_001.glb'
  );
  const { actions } = useAnimations(
    [walkAnimation[0], idleAnimation[0]],
    avatar
  );
  const [animation, setAnimation] = useState<ANIMATIONS_STATE>(
    'M_Standing_Idle_001'
  );

  // memorized position
  const position = useMemo(
    () => new Vector3(props.position?.x, props.position?.y, props.position?.z),
    []
  );

  // Skinned meshes cannot be re-used in threejs without cloning them
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);

  const onPlayerMove = (value: { id: string; pressed: PressedType }) => {
    const { id: socketId, pressed: newPressed } = value;
    if (socketId === id) {
      pressed.current = newPressed;
      socket.emit('updatePosition', socketId, rb.current?.translation());
    }
  };

  useEffect(() => {
    clone.traverse((child) => {
      if (child.isObject3D) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });
  }, [clone]);

  useEffect(() => {
    actions[animation]?.reset().fadeIn(0.25).play();

    return () => {
      actions[animation]?.fadeOut(0.25);
    };
  }, [animation, url]);

  useEffect(() => {
    socket.on('playerMove', onPlayerMove);

    return () => {
      socket.off('playerMove', onPlayerMove);
    };
  }, [id]);

  useFrame((_state) => {
    const { forward, back, left, right } = pressed.current;
    const hips = avatar.current?.getObjectByName('Hips');
    hips?.position.set(0, hips.position.y, 0);

    if (!(avatar.current && rb.current)) return;

    if (id === userId) {
      const updatedLookAt = vec3(rb.current.translation());
      lookAt.current.lerp(updatedLookAt, 0.1);
      _state.camera.lookAt(lookAt.current);
    }

    const velocity = rb.current.linvel();

    const isMove = back || forward || left || right;

    frontVector.set(0, 0, Number(back) - Number(forward));
    sideVector.set(Number(left) - Number(right), 0, 0);

    direction
      .subVectors(frontVector, sideVector)
      .normalize()
      .multiplyScalar(speed);

    rb.current.setLinvel(
      { x: direction.x, y: velocity.y, z: direction.z },
      true
    );

    if (direction.lengthSq() > 0) {
      const quaternion = quat();
      quaternion.setFromUnitVectors(
        vec3({ x: 0, y: 0, z: 1 }),
        direction.clone().normalize()
      );

      avatar.current.quaternion.slerp(quaternion, 0.1);
    }

    if (isMove) setAnimation('M_Walk_001');
    else setAnimation('M_Standing_Idle_001');
  });

  return (
    <group>
      <RigidBody ref={rb} position={position} lockRotations>
        <Chat id={id} />
        <Html position-y={2.35}>
          <h1 className="-translate-x-1/2 transform whitespace-nowrap text-center font-bold">
            {nickname}
          </h1>
        </Html>
        <group name={`player-${id}`} dispose={null}>
          <primitive object={clone} ref={avatar} />
        </group>
        {userId === id && (
          <PerspectiveCamera makeDefault position={[0, 8.5, 13]} near={1} />
        )}
      </RigidBody>
    </group>
  );
});

export default Avatar;

useGLTF.preload('/animations/M_Walk_001.glb');
useGLTF.preload('/animations/M_Standing_Idle_001.glb');
