/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/city city.glb -o src/components/city/index.jsx -r public
*/

import { Html, useGLTF } from '@react-three/drei';
import { useEffect, useMemo, useRef, useState } from 'react';
import { SkeletonUtils } from 'three-stdlib';
import { Vector3 } from '../../lib/three';
import { RapierRigidBody, RigidBody } from '@react-three/rapier';
import { socket } from '../../lib/socket';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

interface AvatarProps {
  url: string;
  id: string;
  nickname: string;
  speed?: number;
  direction?: InstanceType<typeof Vector3>;
  frontVector?: InstanceType<typeof Vector3>;
  sideVector?: InstanceType<typeof Vector3>;
  position?: InstanceType<typeof Vector3>;
}

interface PressedType {
  back: boolean;
  forward: boolean;
  left: boolean;
  right: boolean;
  jump: boolean;
}

const PRESSED_INITIAL_STATE = {
  back: false,
  forward: false,
  left: false,
  right: false,
  jump: false,
};

const Avatar = ({
  url,
  id,
  nickname,
  speed = 3,
  direction = new Vector3(),
  frontVector = new Vector3(),
  sideVector = new Vector3(),
  ...props
}: AvatarProps) => {
  const ref = useRef<InstanceType<typeof RapierRigidBody>>(null);
  const avatar = useRef<InstanceType<typeof THREE.Group>>(null);
  const { scene } = useGLTF(url);
  const [{ forward, back, left, right }, setPressed] = useState<PressedType>(
    PRESSED_INITIAL_STATE
  );

  // memorized position
  const position = useMemo(() => props.position, []);

  // Skinned meshes cannot be re-used in threejs without cloning them
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);

  const onPlayerMove = (value: any) => {
    const { id: socketId, pressed: newPressed } = value;
    if (socketId === id) {
      setPressed(newPressed);
    }
  };

  useEffect(() => {
    clone.traverse((child) => {
      if (child.isObject3D) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });
  }, [clone]);

  useEffect(() => {
    socket.on('playerMove', onPlayerMove);

    return () => {
      socket.off('playerMove', onPlayerMove);
    };
  }, [id]);

  useFrame((_state) => {
    if (!(avatar.current && ref.current)) return;

    const velocity = ref.current.linvel();

    // move
    frontVector.set(0, 0, Number(back) - Number(forward));
    sideVector.set(Number(left) - Number(right), 0, 0);

    direction
      .subVectors(frontVector, sideVector)
      .normalize()
      .multiplyScalar(speed);

    ref.current.setLinvel(
      { x: direction.x, y: velocity.y, z: direction.z },
      true
    );

    if (direction.lengthSq() > 0) {
      const quaternion = new THREE.Quaternion();
      quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, 1),
        direction.clone().normalize()
      );

      avatar.current.quaternion.copy(quaternion);
    }
  });

  return (
    <RigidBody lockRotations ref={ref} type="dynamic">
      <Html
        center
        style={{
          color: '#ffffff',
        }}
        position={new Vector3(0, 2, 0)}
      >
        {nickname}
      </Html>
      <group
        ref={avatar}
        position={position}
        name={`player-${id}`}
        dispose={null}
      >
        <primitive object={clone} />
      </group>
    </RigidBody>
  );
};

export default Avatar;
